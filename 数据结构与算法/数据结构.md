# 【算法分析】

![image-20221013204933521](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013204933521.png)

**O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)**

# 【排序】

## 排序接口

```java
/**
 * @author Chongming
 * @description 排序接口
 * @date 2023年03月06日 15:14
 */
public interface Sort {
    /**
     * 对数组a中的元素进行排序
     * @param a
     */
    void sort(Comparable[] a);

    /**
     * 比较v元素是否大于w元素
     * @param v
     * @param w
     * @return
     */
    default boolean greater(Comparable v, Comparable w){
        return v.compareTo(w) > 0;
    }

    /**
     * 交换数组元素i和j的位置
     * @param a
     * @param i
     * @param j
     */
    default void swap(Comparable[] a, int i, int j){
        Comparable temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

## 测试案例

```java
/**
 * 排序前：{4,5,6,3,2,1}
 * 排序后：{1,2,3,4,5,6}
 */
@Test
public void Test() {
    // 包装类实现了Comparable接口
    Integer[] arr = {4,5,6,3,2,1};
    System.out.println(Arrays.toString(arr));
    sort(arr);
    System.out.println(Arrays.toString(arr));
}
```

## 冒泡排序

**排序原理：**

1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。

![image-20221013210507201](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013210507201.png)

**时间复杂度：** O(n^2)

**API设计：**

![image-20221013210243598](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013210243598.png)

**代码实现：**

```java
/**
 * @author Chongming
 * @description 冒泡排序
 * @date 2022年10月13日 21:06
 */
public class Bubble implements Sort{

    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void Test() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,5,6,3,2,1};
        System.out.println(Arrays.toString(arr));
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 对数组a中的元素进行排序
     * @param a
     */
    @Override
    public  void sort(Comparable[] a){
        for (int i = a.length-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (greater(a[j], a[j+1])) {
                    swap(a, j, j+1);
                }
            }
        }
    }
}
```

## 选择排序

**排序原理：**

1.  每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值

![image-20221013212334425](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013212334425.png)

**时间复杂度：** O(n^2)

**API设计：**

![image-20221013212439185](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013212439185.png)

**代码实现：**

```java
/**
 * @author Chongming
 * @description 选择排序
 * @date 2022年10月13日 21:26
 */
public class Selection implements Sort{

    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void Test() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,5,6,3,2,1};
        System.out.println(Arrays.toString(arr));
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 对数组a中的元素进行排序
     * @param a
     */
    @Override
    public void sort(Comparable[] a){
        for (int i = 0; i < a.length-1; i++) {
            // 默认a[i]为最小元素，minIndex记录最小元素的下标
            int minIndex = i;
            // 找到最小元素的下标
            for (int j = i+1; j < a.length; j++) {
                if (greater(a[minIndex], a[j])) {
                    // 修改最小元素下标
                    minIndex = j;
                }
            }
            swap(a, minIndex, i);
        }
    }
}

```

## 插入排序

**排序原理：**

1. 把所有的元素分为两组，已经排序的和未排序的；
2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入；
3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；

![image-20221013215115150](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013215115150.png)

**时间复杂度：** O(n^2)

**API设计：**

![image-20221013215453439](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013215453439.png)

**代码实现：**

```java
/**
 * @author Chongming
 * @description 插入排序
 * @date 2022年10月13日 21:55
 */
public class Insertion implements Sort{
    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void Test() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,5,6,3,2,1};
        System.out.println(Arrays.toString(arr));
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 对数组a中的元素进行排序
     * @param a
     */
    @Override
    public void sort(Comparable[] a) {
        for (int i = 1; i < a.length; i++) {
            for (int j = i; j > 0; j--) {
                if (greater(a[j-1], a[j])) {
                    swap(a,j-1,j);
                }else {
                    break;
                }
            }
        }
    }
}
```

## 希尔排序

先将待排序表分割成若干个形如L[i, i+d, i+2d, ...， i+kd]的子表，即将相隔某个“增量”的记录组成为一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，对全体进行一次直接插入排序。

**排序原理：**

1. 选定一个增长量h，按照增长量h作为分组的依据

   ```java
   // 确定增长量
   int h = 1;
   while(h < a.length/2) {
       h = 2*h+1;
   }
   ```

2. 对分好组的每一组数据完成插入排序

3. 减小增长量，最小减为1，重复第二步操作

   ```java
   // h的减小规则
   h = h/2;
   ```

![image-20230306153422626](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306153422626.png)

**时间复杂度：**

**API设计：**

![image-20230306151324464](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306151324464.png)

**代码实现：**

```java
/**
 * @author Chongming
 * @description 希尔排序
 * @date 2023年03月06日 15:16
 */
public class Shell implements Sort{

    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void Test() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,5,6,3,2,1};
        System.out.println(Arrays.toString(arr));
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    @Override
    public void sort(Comparable[] a) {
        // 1.根据数组长度，确定h的初始值
        int l = a.length;
        int h = 0;
        while(h < l) {
            h = 2*h+1;
        }
        // 2.希尔排序
        while (h >= 1) {
            // 对子表进行直接插入排序
            for (int i = h; i < l; i++) {
                for (int j = i; j >= h ; j -= h) {
                    if (greater(a[j-h], a[j])) {
                        swap(a, j-h, j);
                    } else {
                        break;
                    }
                }
            }
            h = h/2;
        }
    }
}
```

## 归并排序

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。

将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

**排序原理：**

1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。

2. 将相邻的两个子组进行合并成一个有序的大组

   ![image-20230306163038568](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306163038568.png)

   如图所示，依次将左子组和右子组的数据按顺序放入辅助数组

   最后将辅助数组中已经排好序的值复制到原数组中就行

3. 不断地重复步骤2，直到最终只有一个组为止

![image-20230306161543461](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306161543461.png)

**时间复杂度：** O(nlogn)

**API设计：**

![image-20230306161608024](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306161608024.png)

**代码实现：**

```java
/**
 * @author Chongming
 * @description
 * @date 2023年03月06日 16:16
 */
public class Merge implements Sort{

    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void Test() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,5,6,3,2,1};
        System.out.println(Arrays.toString(arr));
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    // 辅助数组
    private static Comparable[] assist;

    @Override
    public void sort(Comparable[] a) {
        // 1.初始化辅助数组assist，大小与待排序数组大小相同
        // 2.定义一个l变量和r变量，分别记录数组中的最小所以和最大索引
        assist = new Comparable[a.length];
        int l = 0;
        int r = a.length-1;
        // 3.调用sort重载方法，完成数组a中从l到r索引的排序
        sort(a, l, r);
    }

    /**
     * 对数组a中l索引到r索引之间的元素进行排序
     * @param a
     * @param l
     * @param r
     */
    public void sort(Comparable[] a, int l, int r) {
        // 安全性校验
        if (l >= r) {
            return;
        }
        // 将数据分为两个组
        int m = l+(r-l)/2;
        // 对每一组数据进行排序
        sort(a, l, m);
        sort(a, m+1, r);
        // 将两个组的数据进行归并(归并的同时进行排序)
        merge(a, l, m, r);
    }

    /**
     * 索引l~m为一个小组，m+1~r为另一个小组，将数组a中的两个小组合并成一个大组
     * @param a
     * @param l
     * @param m
     * @param r
     */
    public void merge(Comparable[] a, int l, int m, int r) {
        int p1 = l; /*左子组指针*/
        int p2 = m+1; /*右子组指针*/
        int p = l; /*辅助数组指针*/

        // 将子数组排序放入辅助数组中
        while (p1 <= m && p2 <= r) {
            // 比较对应索引处的值
            if (greater(a[p1], a[p2])) {
                assist[p++] = a[p2++];
            } else {
                assist[p++] = a[p1++];
            }
        }
        while (p1 <= m) {
            assist[p++] = a[p1++];
        }
        while (p2 <= r) {
            assist[p++] = a[p2++];
        }

        // 将辅助数组中的值拷贝到原数组
        for (int i = l; i <= r; i++) {
            a[i] = assist[i];
        }
    }
}
```

## 快速排序

快速排序是对冒泡排序的一种改进。

它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**排序原理：**

1. 首先设定一个分界值，通过该分界值将数组分为左右两部分

2. 小于分界值的数据放到数组的左边，大于或等于分界值的数据放到数组右边，

   过程：左指针向右走，右指针向左走，分别交换左指针找到的第一个比分界值大的元素和右指针找到的第一个比分界值小的元素

   此时数组左边元素均小于或等于分界值，右边元素均大于或等于分界值

   

3. 对于左右两部分数据进行独立排序，每次都重复第二步分界方法，进行递归。当左右两侧数据排完序后，整个数组的排序也就完成了

![image-20230306170511099](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306170511099.png)

**时间复杂度：** 最优O(nlogn)，最劣O(n^2)

**API设计：**

![image-20230306170617633](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230306170617633.png)

**代码实现：**

```java
/**
 * @author Chongming
 * @description
 * @date 2023年03月06日 17:06
 */
public class Quick implements Sort{

    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void Test() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,5,6,3,2,1};
        System.out.println(Arrays.toString(arr));
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    @Override
    public void sort(Comparable[] a) {
        int l = 0;
        int r = a.length-1;
        sort(a, l, r);
    }

    void sort(Comparable[] a, int l, int r) {
        if (l >= r) {
            return;
        }
        // 对索引l到r的元素进行分组
        // 1.确定分界值，定义左右指针
        Comparable key = a[l];
        int left = l;
        int right = r;
        // 2.切分
        // 判断left>=right，如果是则证明扫描完毕，退出循环，否则交换两指针对应元素位置
        while (left < right) {
            // right指针从右向左扫描，找到一个比分界值小的元素时停止
            while (greater(a[right], key) && left < right) {
                right--;
            }
            // left指针从左向右扫描，找到一个比分界值大的元素时停止
            while (greater(key, a[left]) && left < right) {
                left++;
            }
            // 交换左右指针对应元素位置
            swap(a, left, right);
        }
        // 交换分界值与right值的位置(循环结束时，right处的值一定小于基准值)
        swap(a, l, right);
        // 排序左子组
        sort(a, l, right-1);
        // 排序右子组
        sort(a, right+1, r);
    }

    @Override
    public boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w) >= 0;
    }
}
```

## 排序算法稳定性

**稳定性的定义：** 

数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保 证A元素依然在B元素的前面，可以说这个该算法是稳定的。

**常见排序算法的稳定性：** 

- 【冒泡排序】 稳定

  只有当arr[i]>arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序算法。 

- 【选择排序】不稳定

  选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2， 所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种不稳定的排序算法。 

- 【插入排序】稳定

  比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等 元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。 

- 【希尔排序】稳定

  希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在 不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不 稳定的。 

- 【归并排序】稳定

  归并排序在归并的过程中，只有arr[i]<arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的。

- 【快速排序】不稳定

  快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素， 然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法。

# 【线性表】

> 线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

**前驱元素：**  若A元素在B元素的前面，则称A为B的前驱元素 **后继元素：**  若B元素在A元素的后面，则称B为A的后继元素 

**线性表的特征：** 数据元素之间具有一种“一对一”的逻辑关系。 

1. 第一个数据元素没有前驱，这个数据元素被称为头结点； 
2. 最后一个数据元素没有后继，这个数据元素被称为尾结点； 
3. 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。

如果把线性表用数学语言来定义，则可以表示为(a1,...ai-1,ai,ai+1,...an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的 前驱元素，ai+1是ai的后继元素

![image-20230307090014550](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307090014550.png)

**线性表的分类：**  线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表

## 顺序表

> 顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存 储线性表中的各个元素、使得线性表中再逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元 素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。

### API设计

![image-20230307090054723](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307090054723.png)

### 顺序表的遍历

​	在java中，遍历集合的方式一般都是用的是foreach循环，如果想让SequenceList也能支持foreach循环，则 需要做如下操作： 

1. 让SequenceList实现Iterable接口，重写iterator方法；
2. 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；

### 容量可变

1. 添加元素时容量不够需要扩容，默认扩容到1.5倍
2. 删除元素时容量过多需要缩容，默认数组元素不足数组容量的1/4时，缩容到0.5倍

### 时间复杂度 

插入时，最优O(1)，最劣O(n)；获取时，O(1)

### 代码实现

```java
/**
 * @author Chongming
 * @description 顺序表
 * @date 2023年03月07日 9:02
 */
public class SequenceList<T> implements Iterable<T>{
    /**
     * 存储元素的数组
     */
    private T[] eles;

    /**
     * 记录当前顺序表中的元素个数
     */
    private int N;

    /**
     * 构造方法
     *
     * @param capacity
     */
    public SequenceList(int capacity) {
        // 初始化数组
        this.eles = (T[]) new Object[capacity];
        // 初始化长度
        this.N = 0;
    }

    /**
     * 将一个线性表置为空表
     */
    public void clear() {
        this.N = 0;
    }

    /**
     * 判断当前线性表是否为空表
     *
     * @return
     */
    public boolean isEmpty() {
        return this.N == 0;
    }

    /**
     * 获取线性表的长度
     *
     * @return
     */
    public int length() {
        return this.N;
    }

    /**
     * 获取指定位置的元素
     *
     * @param i
     * @return
     */
    public T get(int i) {
        return i < N ? eles[i] : null;
    }

    /**
     * 插入元素T
     *
     * @param t
     */
    public void insert(T t) {
        // 扩容
        if (N == eles.length) {
            resize(Math.max(eles.length + eles.length/2, N + 1));
        }
        eles[N++] = t;
    }

    /**
     * 在i元素处插入元素t
     *
     * @param i
     * @param t
     */
    public void insert(int i, T t) {
        // 扩容
        if (N == eles.length) {
            resize(Math.max(eles.length + eles.length/2, N + 1));
        }
        for (int index = N-1; index >= i; index--) {
            eles[index + 1] = eles[index];
        }
        eles[i] = t;
        N++;
    }

    /**
     * 删除指定位置i处的元素，并返回该元素
     *
     * @param i
     * @return
     */
    public T remove(int i) {
        T data = eles[i];
        for (int index = i; index < N - 1; index++) {
            eles[index] = eles[index + 1];
        }
        N--;

        // 缩容
        if (N < eles.length/4) {
            resize(eles.length/2);
        }
        return data;
    }

    /**
     * 重置数组的大小
     * @param newSize
     */
    public void resize(int newSize) {
        // 定义一个临时引用，指向原数组
        T[] temp = eles;
        // 创建新数组
        eles = (T[])new Object[newSize];
        // 把原数组的数据拷贝到新数组
        for (int i = 0; i < N; i++) {
            eles[i] = temp[i];
        }
    }

    /**
     * 查找t元素第一次出现的位置
     *
     * @param t
     * @return
     */
    public int indexOf(T t) {
        for (int i = 0; i < N; i++) {
            if (t.equals(eles[i])) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 实现迭代器
     * @return
     */
    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            private int cusor = 0;
            @Override
            public boolean hasNext() {
                return cusor<N;
            }

            @Override
            public T next() {
                return eles[cusor++];
            }
        };
    }

}
```

**测试代码：**

```java
// 创建顺序表对象
SequenceList<String> sl = new SequenceList<>(1);
// 测试插入
sl.insert("姚明");
sl.insert("科比");
sl.insert("麦迪");
sl.insert(1, "詹姆斯");
// 遍历熟悉表
for (String s : sl) {
    System.out.println(s);
}
System.out.println("------------------------------------------");
// 测试获取
String getResult = sl.get(1);
System.out.println("获取索引1处的结果为：" + getResult);
// 测试删除
String removeResult = sl.remove(0);
System.out.println("删除的元素是：" + removeResult);
// 测试清空
sl.clear();
System.out.println("清空后的线性表中的元素个数为:" + sl.length());
```

## 链式表

> 链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能直接的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。

![image-20230307100851502](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307100851502.png)

### 单向链表

> 单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。

![image-20230307103428440](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307103428440.png)

#### 结点

![image-20230307101008042](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307101008042.png)

**代码实现：**

```java
public class Node<T> {
    public T item;
    public Node next;
    public Node(T item, Node next) {
        this.item = item;
        this.next = next;
    }
}
```



#### API设计

![image-20230307103450701](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307103450701.png)

#### 代码实现

```java
/**
 * @author Chongming
 * @description 单向链表
 * @date 2023年03月07日 10:35
 */
public class LinkList<T> implements Iterable<T>{
       /**
     * 记录头结点
     */
    private Node head;

    /**
     * 记录链表长度
     */
    private int N;

    /**
     * 结点数据结构
     */
    private class Node {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    /**
     * 初始化链表
     */
    public LinkList() {
        // 初始化头结点
        this.head = new Node(null, null);
        // 初始化元素个数
        this.N = 0;
    }

    /**
     * 清空链表
     */
    public void clear() {
        head.next = null;
        this.N = 0;
    }

    /**
     * 获取链表长度
     * @return
     */
    public int length() {
        return N;
    }

    /**
     * 判断链表是否为空
     * @return
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * 获取指定位置i的元素
     * @param i
     * @return
     */
    public T get(int i) {
        if (i >= N) {
            return null;
        }
        Node temp = this.head;
        for (int index = 0; index <= i; index++) {
            temp = temp.next;
        }
        return temp.item;
    }

    /**
     * 向链表中添加元素
     * @param t
     */
    public void insert(T t) {
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = new Node(t, null);
        N++;
    }

    /**
     * 向指定位置i处添加元素
     * @param i
     * @param t
     */
    public void insert(int i, T t) {
        if (i >= N) {
            insert(t);
        }
        Node temp = head;
        // 找到i-1处的结点
        for (int index = 0; index < i; index++) {
            temp = temp.next;
        }
        temp.next = new Node(t, temp.next);
        N++;
    }

    /**
     * 删除指定位置i处的元素，并返回被删除的元素
     * @param i
     * @return
     */
    public T remove(int i) {
        Node temp = head;
        for (int index = 0; index < i; index++) {
            temp = temp.next;
        }
        T item = temp.next.item;
        temp.next = temp.next.next;
        N--;
        return item;
    }

    /**
     * 查找元素t在链表中第一次出现的位置
     * @param t
     * @return
     */
    public int indexOf(T t) {
        Node temp = head;
        for (int i = 0; temp.next != null; i++) {
            temp = temp.next;
            if (t.equals(temp.item)) {
                return i;
            }
        }
        return -1;
    }

    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            private Node temp = head;
            @Override
            public boolean hasNext() {
                return temp.next != null;
            }

            @Override
            public T next() {
                temp = temp.next;
                return temp.item;
            }
        };
    }
}
```

**测试代码：**

```java
// 创建顺序表对象
LinkList<String> ls = new LinkList<>();
// 测试插入
ls.insert("姚明");
ls.insert("科比");
ls.insert("麦迪");
ls.insert(1, "詹姆斯");
// 遍历熟悉表
for (String s : ls) {
    System.out.println(s);
}
System.out.println("------------------------------------------");
// 测试获取
String getResult = ls.get(1);
System.out.println("获取索引1处的结果为：" + getResult);
// 测试删除
String removeResult = ls.remove(0);
System.out.println("删除的元素是：" + removeResult);
// 测试清空
ls.clear();
System.out.println("清空后的线性表中的元素个数为:" + ls.length());
```

### 双向链表

> 双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用 来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。

![image-20230307110319507](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307110319507.png)

#### 结点

![image-20230307110344781](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307110344781.png)

**代码实现：**

```java
public class Node<T> {
    public T item;
    public Node pre;
    public Node next;
    public Node(T item, Node pre, Node next) {
        this.item = item;
        this.pre = pre;
        this.next = next;
    }
}
```

#### API设计

![image-20230307110618513](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307110618513.png)

#### 代码实现

```java
/**
 * @author Chongming
 * @description 双向链表
 * @date 2023年03月07日 11:07
 */
public class DoubleLinkList<T> implements Iterable<T> {
    /**
     * 头结点
     */
    private Node head;
    /**
     * 尾结点
     */
    private Node last;
    /**
     * 链表长度
     */
    private int N;

    /**
     * 结点数据结构
     */
    private class Node {
        public T item;
        public Node pre;
        public Node next;

        public Node(T item, Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
    }

    public DoubleLinkList() {
        // 初始化头尾结点
        this.head = new Node(null, null, null);
        this.last = null;
        // 初始化元素个数
        this.N = 0;
    }

    /**
     * 清空链表
     */
    public void clear() {
        this.head.next = null;
        this.last = null;
        this.N = 0;
    }

    /**
     * 获取链表长度
     *
     * @return
     */
    public int length() {
        return N;
    }

    /**
     * 链表判断空
     *
     * @return
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * 获取链表第一个元素
     *
     * @return
     */
    public T getFirst() {
        return isEmpty() ? null : head.next.item;
    }

    /**
     * 获取最后一个元素
     *
     * @return
     */
    public T getLast() {
        return isEmpty() ? null : last.item;
    }

    /**
     * 插入元素t
     *
     * @param t
     */
    public void insert(T t) {
        if (!isEmpty()) {
            last.next = new Node(t, last, null);
            last = last.next;
        } else {
            last = new Node(t, head, null);
            head.next = last;
        }
        N++;
    }

    /**
     * 向指定位置i插入元素t
     *
     * @param i
     * @param t
     */
    public void insert(int i, T t) {
        if (i == N) {
            insert(t);
            return;
        }
        Node temp = head;
        // 找到当前i-1位置的元素
        for (int index = 0; index < i; index++) {
            temp = temp.next;
        }
        temp.next.pre = new Node(t, temp, temp.next);
        temp.next = temp.next.pre;
        N++;
    }

    /**
     * 获取指定位置i处的元素
     *
     * @param i
     * @return
     */
    public T get(int i) {
        Node temp = head;
        for (int index = 0; index <= i; index++) {
            temp = temp.next;
        }
        return temp.item;
    }

    /**
     * 找到元素t第一次出现的位置
     *
     * @param t
     * @return
     */
    public int indexOf(T t) {
        Node temp = head;
        for (int i = 0; temp.next != null; i++) {
            temp = temp.next;
            if (t.equals(temp.item)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 删除i位置的结点并返回元素
     *
     * @param i
     * @return
     */
    public T remove(int i) {
        if (i >= N) {
            return null;
        }
        Node temp = head;
        // 找到i-1结点
        for (int index = 0; index < i; index++) {
            temp = temp.next;
        }
        T item = temp.next.item;
        temp.next = temp.next.next;
        temp.next.pre = temp;
        N--;
        return item;
    }

    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            private Node temp = head;
            @Override
            public boolean hasNext() {
                return temp.next != null;
            }

            @Override
            public T next() {
                temp = temp.next;
                return temp.item;
            }
        };
    }
}
```

**测试代码：**

```java
// 创建顺序表对象
LinkList<String> ls = new LinkList<>();
// 测试插入
ls.insert("姚明");
ls.insert("科比");
ls.insert("麦迪");
ls.insert(1, "詹姆斯");
// 遍历熟悉表
for (String s : ls) {
    System.out.println(s);
}
System.out.println("-------");
// 测试获取
String getResult = ls.get(1);
System.out.println("获取索引1处的结果为：" + getResult);
// 测试删除
String removeResult = ls.remove(0);
System.out.println("删除的元素是：" + removeResult);
// 测试清空
ls.clear();
System.out.println("清空后的线性表中的元素个数为:" + ls.length());
```

### 链表反转

**需求：**

原链表中数据为：1->2->3>4

反转后链表中数据为：4->3->2->1

**反转API：**

`public void reverse()`：对整个链表反转 

`public Node reverse(Node curr)`：反转链表中的某个结点curr,并把反转后的curr结点返回

![image-20230307194455353](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307194455353.png)

**代码实现：**

```java
/**
 * 反转单链表
 */
public void reverse() {
    if (isEmpty()) {
        return;
    }
    reverse(head.next);
}
/**
 * 反转当前结点，并把反转后的结点返回
 * @param node
 * @return
 */
private Node reverse(Node node) {
    // 让头结点指向最后一个结点
    if (node.next == null) {
        head.next = node;
        return node;
    }
    // 递归得到当前结点的下一个结点，使其指针域指向当前结点
    reverse(node.next).next = node;
    // 把当前结点的指针域设为null(否则遍历会有问题)
    node.next = null;
    return node;
}
```

**测试代码：**

```java
// 创建顺序表对象
LinkList<String> ls = new LinkList<>();
// 测试插入
ls.insert("姚明");
ls.insert("科比");
ls.insert("麦迪");
ls.insert(1, "詹姆斯");
// 遍历熟悉表
for (String s : ls) {
    System.out.println(s);
}
System.out.println("-------测试反转-------");
ls.reverse();
for (String s : ls) {
    System.out.println(s);
}
```

### 快慢指针

> 快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以帮助找到链表上相应的结点。
>
> 一般情况下，快指针的移动步长为慢指针的两倍

#### 寻找中间值

**需求：** 完善`getMid()`方法，查找链表中的中间元素

**原理：**

![image-20230307201124483](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307201124483.png)

1. 快慢指针遍历链表，快指针步长为2，慢指针步长为1
2. 当元素个数是奇数时，`fast.next == null`
3. 当元素个数是偶数时，`fast == null`
4. 遍历结束时，慢指针指向的位置就是中间值

**代码实现：**

```java
/**
 * @author Chongming
 * @description 快慢指针-寻找中间值
 * @date 2023年03月07日 20:07
 */
public class FastAndSlowPoint {
    public static void main(String[] args) throws Exception {
        // 创建链表
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        // 查找中间值
        String mid = getMid(first);
        System.out.println("中间值为："+mid);
    }
    /**
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
    public static String getMid(Node<String> first) {
        // 定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;
        // 使用两个指针遍历链表，快指针步长2，慢指针步长1
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow.item;
    }
    private static class Node<T> {
        T item;
        Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

#### 链表成环

**需求：** 判断单向链表中是否有环

![image-20230307201712653](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230307201712653.png)

**原理：**

快指针步长2，慢指针步长1。

如果`fast == null`或者`fast.next == null`，则链表无环。

如果链表成环，则快指针会追上慢指针，即`fast == slow`，且快慢指针相遇的地方就是环的入口。

![1DF2D98FDF171831678FEDDBCB2CE6C2](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-master1DF2D98FDF171831678FEDDBCB2CE6C2.png)

**代码实现：**

```java
/**
 * 判断链表中是否有环，并返回环入口
 * @param first 链表首结点
 * @return -1代表无环，i >= 0 代表有环
 */
public static int isCircle(Node<String> first) {
    // 定义快慢指针和记录i(记录i的位置)
    Node<String> fast = first;
    Node<String> slow = first;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast.equals(slow)) {
            fast = first;
            int i = 1;
            while (!fast.equals(slow)) {
                fast = fast.next;
                i++;
            }
            return i+1;
        }
    }
    return -1;
}
```

**测试代码：**

```java
// 链表
Node<String> first = new Node<String>("aa", null);
Node<String> second = new Node<String>("bb", null);
Node<String> third = new Node<String>("cc", null);
Node<String> fourth = new Node<String>("dd", null);
Node<String> fifth = new Node<String>("ee", null);
Node<String> six = new Node<String>("ff", null);
Node<String> seven = new Node<String>("gg", null);
first.next = second;
second.next = third;
third.next = fourth;
fourth.next = fifth;
fifth.next = six;
six.next = seven;
// 产生环
seven.next = third;
// 判断链表是否有环
int circle = isCircle(first);
System.out.println("first链表的环入口："+circle);
```

### 循环链表

> 循环链表，顾名思义，链表整体要形成一个圆环状。
>
> 在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。
>
> 要实现循环链表，只需要让单向链表的最后一个节点的指针指向头结点即可。

![image-20230308194134817](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230308194134817.png)

### 约瑟夫问题

**问题描述：** 

传说有这样一个故事，在罗马人占领乔塔帕特后，39个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。

然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏。 

**问题转换：** 

41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。 

1. 编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈； 
2. 自退出那个人开始的下一个人再次从1开始报数，以此类推； 
3. 求出最后退出的那个人的编号。

![image-20230308194400363](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230308194400363.png)

**解题思路：**

1. 构建含有41个结点的单向循环链表，分别存储1-41的值
2. 使用计数器count，记录当前报数的值
3. 遍历链表，每循环一次，count++；
4. 判断count的值，如果是3，则从链表中删除这个结点并重置计数器，将count设置为0；

**代码实现：**

```java
public static void main(String[] args) {
    int n = 41;
    // 构建循环链表
    Node<Integer> first = null;
    Node<Integer> pre = null;
    for (int i = 1; i <= n; i++) {
        // 如果是第一个结点
        if (i == 1) {
            first = new Node(1, null);
            pre = first;
            continue;
        }
        // 不是第一个结点
        Node<Integer> node = new Node<>(i, null);
        pre.next = node;
        pre = node;
        // 最后一个结点
        if (i == n) {
            node.next = first;
        }
    }
    // 报数并删除报数到3的结点
    int count = 1;
    Node temp = first;
    Node before = null;
    while (!temp.equals(temp.next)) {
        // 当前结点不是3，让当前结点后移
        before = temp;
        temp = temp.next;
        // 模拟报数
        count++;
        // count为3时删除当前结点
        if (count == 3) {
            System.out.println("删除的结点是:" + temp.data);
            before.next = temp.next;
            temp = before;
            count = 0;
        }
    }
    // 最后两个打印的元素应该是16和31
    System.out.println("最后一个结点是:" + temp.data);
}
public static class Node<T> {
    T data;
    Node<T> next;
    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }
}
```

## 栈

> 栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一 个数据被第一个读出来）。

![image-20230308202804525](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230308202804525.png)

### API设计

![image-20230308202834245](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230308202834245.png)

### 代码实现

```java
/**
 * @author Chongming
 * @description 栈
 * @date 2023年03月08日 20:29
 */
public class Stack<T> implements Iterable<T>{
    private Node head;  /* 记录首个结点，该结点为仅有指针域 */
    private int N; /* 记录栈中元素个数 */

    private class Node<T> {
        public T data;
        public Node next;

        public Node(T data, Node next) {
            this.data = data;
            this.next = next;
        }
    }

    public Stack() {
        this.head = new Node(null, null);
        this.N = 0;
    }

    /**
     * 判断栈是否为空
     * @return
     */
    public boolean isEmpty() {
        return N==0;
    }

    /**
     * 返回栈中元素个数
     * @return
     */
    public int size() {
        return N;
    }

    /**
     * 压栈
     * @param t
     * @return
     */
    public boolean push(T t) {
        head.next = new Node(t, head.next);
        N++;
        return true;
    }

    /**
     * 弹栈
     * @return
     */
    public T pop() {
        Node temp = head.next;
        if (temp == null) {
            return null;
        }
        head.next = temp.next;
        N--;
        return (T) temp.data;
    }

    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            private Node temp = head;
            @Override
            public boolean hasNext() {
                return temp.next != null;
            }

            @Override
            public T next() {
                temp = temp.next;
                return (T) temp.data;
            }
        };
    }
}
```

**测试代码：**

```java
public static void main(String[] args) {
    // 创建栈对象
    Stack<String> stack = new Stack<>();
    // 测试压栈
    stack.push("a");
    stack.push("b");
    stack.push("c");
    stack.push("d");
    for (String item : stack) {
        System.out.println(item);
    }
    System.out.println("------------------------------");
    // 测试弹栈
    String result = stack.pop();
    System.out.println("弹出的元素是："+result);
    System.out.println("剩余的元素个数："+stack.size());
}
```

### 括号匹配问题

**问题描述：**

![image-20230308205824138](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230308205824138.png)

**代码实现：**

```java
@Test
public void BracketMatch() {
    String str = "(上海(长安)()";
    System.out.println("括号是否匹配：" + isMatch(str));
}
/**
 * 判断str中的符号是否匹配
 * 遍历字符串，遇到左括号入栈
 * 遇到右括号，弹栈直到弹出一个左括号
 * 若栈中无左括号与右括号匹配，或者遍历完后仍有左括号剩余，则符号不匹配
 * @param str
 * @return
 */
private boolean isMatch(String str) {
    Stack<Character> stack = new Stack<>();
    for (char s : str.toCharArray()) {
        if (s == '(') {
            stack.push(s);
        } else if (s == ')') {
            if (stack.pop() == null) {
                return false;
            }
        }
    }
    return stack.size() == 0;
}
```

### 逆波兰表达式

**中缀表达式：** 运算符总是位于两个操作数中间

**逆波兰表达式(后缀表达式)：** 运算符总是放在跟它相关的操作数之后

![image-20230308211430343](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230308211430343.png)

**需求：**

给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果

**中缀表达式转后缀表达式：**

1. 初始化 **两个栈** ，运算符栈`operator`和存储中间结果的栈`express`
2. 从左至右扫描中缀表达式
3. 遇到操作数时直接压入`express`
4. 遇到运算符时，比较其与`operator`栈顶运算符的优先级
   1. 如果`operator`为空，或栈顶运算符为左括号"("，则直接将运算符压入`operator`
   2. 否则，若优先级比栈顶运算符的高，也将压入运算符`express`
   3. 否则，将`operation`栈顶的运算符弹出并压入到`express`中，返回4.1步骤与`operator`中新的栈顶运算符相比较
5. 遇到括号时：
   1. 如果是左括号"("，则直接压入`operator`
   2. 如果是右括号")"，则一次弹出`operator`栈顶的运算符，并压入`express`，直到遇到左括号为止，此时将着一对括号丢弃
6. 重复2至5，直到表达式的最右边
7. 将`operator`中剩余的运算符依次弹出并压入`exress`
8. 依次弹出`express`中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

**后缀表达式计算：**

1. 创建一个栈对象operands操作数
2. 从左往右遍历逆波兰表达式，得到每一个字符串
3. 判断该字符串是不是运算符，如果不是，把该该操作数压入operands栈中
4. 如果是运算符，则从operands栈中弹出两个操作数o1,o2
5. 使用该运算符计算o1和o2，得到结果result
6. 把该结果压入operands栈中
7. 遍历结束后，拿出栈中最终的结果返回

**代码实现：**

```java
@Test
public void calculateTest() {
    //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9
    String[] notation = {"3", "17", "15", "-", "*", "18", "6", "/", "
    System.out.println("逆波兰表达式的结果为：" + calculate(notation)); // 9
}

/**
 * 逆波兰表达式计算
 * @param express
 * @return
 */
private static String calculate(String[] express) {
    // 定义操作数栈
    Stack<String> operands = new Stack<>();
    // 判断当前元素运算符还是操作数
    for (int i = 0; i < express.length; i++) {
        Integer o1;
        Integer o2;
        switch (express[i]) {
            // 运算符：弹出两个操作数并运算，结果压入栈
            case "+" :
                o1 = Integer.valueOf(operands.pop());
                o2 = Integer.valueOf(operands.pop());
                operands.push(String.valueOf((o2+o1)));
                break;
            case "-" :
                o1 = Integer.valueOf(operands.pop());
                o2 = Integer.valueOf(operands.pop());
                operands.push(String.valueOf((o2-o1)));
                break;
            case "*" :
                o1 = Integer.valueOf(operands.pop());
                o2 = Integer.valueOf(operands.pop());
                operands.push(String.valueOf((o2*o1)));
                break;
            case "/" :
                o1 = Integer.valueOf(operands.pop());
                o2 = Integer.valueOf(operands.pop());
                operands.push(String.valueOf((o2/o1)));
                break;
            // 操作数：压入操作数栈
            default:
                operands.push(express[i]);
                break;
        }
    }
    return operands.pop();
}
```

## 队列

> 队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它 按照先进先出的原则存储数据，先进入的数据，在读取数据时先被读出来。

![image-20230309091603168](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230309091603168.png)

### API设计

![image-20230309091642731](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230309091642731.png)

### 代码实现

```java
/**
 * @author Chongming
 * @description 队列
 * @date 2023年03月09日 9:18
 */
public class Queue<T> implements Iterable<T>{
    // 记录首结点
    private Node head;
    // 记录最后一个结点
    private Node last;
    // 记录队列中元素的个数
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    /**
     * 构造方法
     */
    public Queue() {
        this.head = new Node(null,null);
        this.last = null;
        this.N=0;
    }

    /**
     * 判断队列是否为空
     * @return
     */
    public boolean isEmpty(){
        return N==0;
    }

    /**
     * 返回队列中元素的个数
     * @return
     */
    public int size(){
        return N;
    }

    /**
     * 向队列中插入元素t
     * @param t
     */
    public void enqueue(T t){
        if (last == null) {
            last = new Node(t, null);
            head.next = last;
        } else {
            last.next = new Node(t, null);
            last = last.next;
        }
        N++;
    }

    /**
     * 从队列中取出元素
     * @return
     */
    public T dequeue(){
        if (isEmpty()) {
            return null;
        }
        Node temp = head.next;
        head.next = temp.next;
        N--;
        // 如果列表为空，重置last
        if (isEmpty()) {
            last = null;
        }
        return temp.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new Iterator() {
            private Node temp = head;
            @Override
            public boolean hasNext() {
                return temp.next != null;
            }
            @Override
            public Object next() {
                temp = temp.next;
                return temp.item;
            }
        };
    }

}
```

**测试代码：**

```java
// 创建队列对象
Queue<String> q = new Queue<>();
// 测试队列的enqueue方法
q.enqueue("a");
q.enqueue("b");
q.enqueue("c");
q.enqueue("d");
for (String str : q) {
    System.out.println(str);
}
System.out.println("-------------------------------");
// 测试队列的dequeue方法
String result = q.dequeue();
System.out.println("出队列的元素是：" + result);
System.out.println("剩余的元素个数：" + q.size());
```

# 【符号表】

> 符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的 键值对数据，可以根据键来查找对应的值。
>
> 符号表中，键具有唯一性。

![image-20230309093420577](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230309093420577.png)

## API设计

**结点类：**

![image-20230309093454473](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230309093454473.png)

**符号表：**

![image-20230309093519910](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230309093519910.png)

## 代码实现

```java
package datastruct.symbolTable;

/**
 * @author Chongming
 * @description 符号表
 * @date 2023年03月09日 9:42
 */
public class SymbolTable<Key,Value> {
    // 记录首结点
    private Node head;
    // 记录符号表中元素的个数
    private int N;

    private class Node{
        // 键
        public Key key;
        // 值
        public Value value;
        // 下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    /**
     * 构造方法
     */
    public SymbolTable() {
        this.head = new Node(null,null,null);
        this.N=0;
    }

    /**
     * 获取符号表中键值对的个数
     * @return
     */
    public int size(){
        return N;
    }

    /**
     * 向符号表中插入键值对
     * @param key
     * @param value
     */
    public void put(Key key,Value value){
        // 如果符号表中已存在key，这替换value
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
            if (temp.key.equals(key)) {
                temp.value = value;
                return;
            }
        }
        // 如果符号表中不存在键值对，则插入键值对到链表头部
        head.next = new Node(key, value, head.next);
        N++;
        return;
    }

    /**
     * 根据key删除键值对
     * @param key
     */
    public void delete(Key key){
        // 找到键为key的结点的前一个结点，把键为key的结点从链表中删除
        Node temp = head;
        while (temp.next != null) {
            if (key.equals(temp.next.key)) {
                temp.next = temp.next.next;
                N--;
            }
            temp = temp.next;
        }
        return;
    }

    /**
     * 根据key获取值
     * @param key
     * @return
     */
    public Value get(Key key){
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
            if (temp.key.equals(key)) {
                return temp.value;
            }
        }
        return null;
    }
}
```

**测试代码：**

```java
// 构造符号表
SymbolTable<Integer, String> symbolTable = new SymbolTable<>();
symbolTable.put(1, "jojo");
symbolTable.put(2, "dio");
symbolTable.put(3, "川哥");
// 测试put和size方法
System.out.println(symbolTable.size());
// 测试get方法
System.out.println(symbolTable.get(2));
// 测试删除方法
symbolTable.delete(2);
System.out.println(symbolTable.size());
```

## 有序符号表

